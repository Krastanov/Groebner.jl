<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/Groebner.jl/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/Groebner.jl/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/Groebner.jl/css/franklin.css">
<link rel="stylesheet" href="/Groebner.jl/css/poole_hyde.css">
<link rel="stylesheet" href="/Groebner.jl/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/Groebner.jl/assets/favicon.png">

   <title>Groebner.jl — Tutorial</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/Groebner.jl/">Groebner<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/Groebner.jl/">Home</a>
      <!-- <a class="sidebar-nav-item {{ispage tutorial.html}}active{{end}}" href="/Groebner.jl/tutorial/">Tutorials</a> -->
      <li class="sidebar-nav-item active"><a href="/Groebner.jl/tutorial/">Tutorials</a>
			  <ul class="menu-list-child-list ">
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#introduction" class="menu-list-link">Introduction</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#gcd_rref" class="menu-list-link">Gcd & Rref</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#variable_elimination" class="menu-list-link">Variable Elimination</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#curve_implicitization" class="menu-list-link">Curve Implicitization</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#system_solving" class="menu-list-link">System Solving</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#integer_programming" class="menu-list-link">Integer Programming</a>
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/#graph_coloring" class="menu-list-link">Graph Coloring</a>
				<!-- <li class="menu-list-item {{ispage index.html}}active{{end}}"><a href="/Groebner.jl/tutorial/" class="menu-list-link">Page structure</a> -->
			  </ul>
      <a class="sidebar-nav-item " href="/Groebner.jl/interface/">Interface</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/sumiya11/Groebner.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="tutorials"><a href="#tutorials" class="header-anchor">Tutorials</a></h1>

<h2 id="introduction"><a href="#introduction" class="header-anchor">Introduction</a></h2>
<p>The following contains a series of tutorials on basics and interesting usecases of Groebner bases provided with the code from <code>Groebner.jl</code>.</p>
<h3 id="so_what_is_groebner_basis"><a href="#so_what_is_groebner_basis" class="header-anchor">So, what is Groebner basis?</a></h3>
<p><em>In short, a Groebner basis is a good representation of infinite information.</em></p>
<p>Let us recall some theory from an algebra course. A set of polynomials \(F = \{f_1, \ldots, f_m \}\) is said to <em>generate an infinite</em> set \(I\):</p>
\[
  I = \{ f_1h_1 + f_2h_2 + \ldots + f_nh_n ~~|~~ h_i ~arbitrary \}
\]
<p>Such \(I\) is usually called <em>an Ideal generated by</em> \(\{f_i\}\). A Groebner basis of \(I\) is a <em>nicer set of generators</em> for \(I\). E.g., if \(F\) is</p>
<pre><code class="language-julia">using AbstractAlgebra
_, &#40;x, y&#41; &#61; QQ&#91;&quot;x&quot;, &quot;y&quot;&#93;
F &#61; &#91;x^3 &#43; y^2, x*y &#43; x^2&#93;;</code></pre>
<p>In this example, the Groebner basis of <code>F</code> is</p>
<pre><code class="language-julia">using Groebner
G &#61; groebner&#40;F&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 y^3 - y^2
 x*y^2 + y^2
 x^2 + x*y</code></pre>
<p>Every set of polynomials has a Groebner basis. But why is it <em>nice</em>?</p>
<p>First of all, the Groebner basis <strong>is unique</strong>&#33; That is, if two sets of polynomials \(F_1\) and \(F_2\) generate the same Ideal &#40;which is actually infinite&#41;, then their Groebner bases &#40;which are finite&#41; are the same and can be compared directly</p>
<pre><code class="language-julia">F₁ &#61; &#91;x^3 &#43; y^3, x*y &#43; x^2, x^3 - y^2&#93;
F₂ &#61; &#91;x^3 - y^2, x*y &#43; x^2&#93;
groebner&#40;F₁&#41; &#61;&#61; groebner&#40;F₂&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>So, a Groebner basis is a <em>unique and finite</em> representation for symbolic systems, combinatorial relations, and everything else that can be encoded with polynomials.</p>
<p>Secondly, Groebner bases allow some algebraic operations over polynomials and Ideals, which are unattainable without it. As an example, with Groebner bases we can do <em>multivariate polynomial division by a set</em> &#40;i.e., <strong>normal form</strong> computation&#41;. With a polynomial \(f\) and a set of polynomials \(F\), one can divide \(f\) by \(F\) &#40;i.e., produce a <strong>unique</strong> reminder of \(f\) modulo \(F\)&#41; by computing the normal form of \(f\) w.r.t. the Groebner basis of \(F\).</p>
<p><code>Groebner.jl</code> provides normal form functionality with the <code>normalform</code> function.</p>
<pre><code class="language-julia">F &#61; &#91;x^3 &#43; y^2, x*y &#43; x^2&#93;
f &#61; x^4*y^2 &#43; y^3 &#43; x^2 &#43; x*y &#43; 1

G &#61; groebner&#40;F&#41;     # compute the basis
normalform&#40;G, f&#41;    # &quot;divide&quot; f by G</code></pre><pre><code class="plaintext code-output">2*y^2 + 1</code></pre>
<p>The normal form is used in study of algebraic questions regarding Ideals: Ideal membership problem, Ideal quotient space basis finding, and a lot more.</p>
<h2 id="gcd_rref"><a href="#gcd_rref" class="header-anchor">Gcd &amp; Rref</a></h2>
<p>Computing a Groebner basis for a general system of nonlinear equations is nontrivial, both from theoretic and computational perspectives. Still, the two widely known algorithms can give us some intuition behind this process.</p>
<h3 id="groebner_basis_is_gaussian_elimination"><a href="#groebner_basis_is_gaussian_elimination" class="header-anchor">Groebner basis is Gaussian Elimination</a></h3>
<p>For a <strong>linear</strong> system, a Groebner basis mirrors the row echelon form. That is, computing a Groebner basis is <em>a nonlinear generalization of Gaussian elimination</em> process for systems of algebraic equations.</p>
<p>Indeed, applied to a linear system, Groebner basis algorithms produce row echelon matrix form</p>
<pre><code class="language-julia">@polyvar x y z
system &#61; &#91;
       x - y &#43; z &#43; 1,
       x &#43; 2y &#43; 3z &#43; 4,
       x &#43; y &#43; 5z &#43; 3
&#93;

groebner&#40;system&#41;  # rref</code></pre><pre><code class="plaintext code-output">3-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 z
 y + 1
 x + 2</code></pre>
<p>and imply \(z = 0, ~y = -1, ~x = -2\).</p>
<h3 id="groebner_basis_is_euclidean_algorithm"><a href="#groebner_basis_is_euclidean_algorithm" class="header-anchor">Groebner basis is Euclidean Algorithm</a></h3>
<p>In case the system is <strong>univariate</strong>, a Groebner basis coincides with the GCD of system generators. One can even say that computing a Groebner basis is a <em>multivariate generalization of applying Euclidean Algorithm</em></p>
<pre><code class="language-julia">@polyvar x
f &#61; &#40;x^2 - 1&#41;^7*&#40;x &#43; 3&#41;*&#40;x - 7&#41;^4
g &#61; &#40;x &#43; 3&#41;*&#40;x &#43; 7&#41;

groebner&#40;&#91;f, g&#93;&#41;   # gcd by groebner</code></pre><pre><code class="plaintext code-output">1-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 x + 3</code></pre>
<pre><code class="language-julia">gcd&#40;f, g&#41;          # usual gcd</code></pre><pre><code class="plaintext code-output">x + 3</code></pre>
<p>Same holds for several input polynomials:</p>
\[
groebner(f_1, \ldots, f_m) = gcd(gcd(gcd(f_1, f_2), \ldots), f_m)
\]
<p>So, you can compute the GCD of several polynomials at once using <code>Groebner.jl</code>&#33;</p>
<p>We emphasize that <code>Groebner.jl</code> is designed to have as little runtime overhead as possible over the usual GCD implementation even for simple input.</p>
<p>With <code>DynamicPolynomials.jl</code>:</p>
<pre><code class="language-julia">h &#61; &#40;x &#43; 3&#41;^5

@btime gcd&#40;gcd&#40;&#36;f, &#36;g&#41;, &#36;h&#41;</code></pre><pre><code class="plaintext code-output">  293.823 μs (3566 allocations: 223.52 KiB)
x + 3</code></pre>
<p>With <code>Groebner.jl</code>:</p>
<pre><code class="language-julia">F &#61; &#91;f, g, h&#93;
@btime groebner&#40;&#36;F&#41;</code></pre><pre><code class="plaintext code-output">  133.511 μs (1212 allocations: 126.03 KiB)
1-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 x + 3</code></pre>
<h2 id="variable_elimination"><a href="#variable_elimination" class="header-anchor">Variable Elimination</a></h2>
<p>One can also use Groebner bases to <em>eliminate indeterminates</em> from equations. A layer of theory lies behind this topic, however, the main simple observation here is that</p>
<hr />
<p>If \(G\) is a Groebner basis of Ideal \(I\) with variables ordered as \(x > y > z\), then</p>
\[
G \cap R[y, z]
\]
<p>is a Groebner basis for \(I_{y, z}~ =~ I \cap R[y, z]\).</p>
<hr />
<p>Here, one can see \(I_{y, z}\) as a fair geometric projection of \(I\) onto the last two variables \(y, z\).</p>
<p>For example, consider polynomial set \(F\) that encodes some complicated algebraic variety in 3D:</p>
<pre><code class="language-julia">_, &#40;x, y, z&#41; &#61; QQ&#91;&quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#93;

F &#61; &#91;x &#43; y^2 &#43; z - 1,
     x &#43; y &#43; z^2 - 1&#93;</code></pre><pre><code class="plaintext code-output">2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x + y^2 + z - 1
 x + y + z^2 - 1</code></pre>
<p>Let&#39;s try to simplify it a bit. Now, the Groebner basis of \(F\) is</p>
<pre><code class="language-julia">G &#61; groebner&#40;F&#41;</code></pre><pre><code class="plaintext code-output">2-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 y^2 - y - z^2 + z
 x + y + z^2 - 1</code></pre>
<p>Notice that the first polynomial in <code>G</code> does not contain <code>x</code>&#33; The observation implies that <code>G&#91;1&#93;</code> is a Groebner basis of \(I_{y, z}\), meaning the solutions of</p>
\[
y^2 - y - z^2 + z = 0
\]
<p>are exactly the projection of solutions of \(F\) to variables \(y\) and \(z\).</p>
<p>With this technique, one can split a complicated variety in parts, and treat each part separately.</p>
<h2 id="curve_implicitization"><a href="#curve_implicitization" class="header-anchor">Curve Implicitization</a></h2>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">For some reason Tex in this subsection is not compiled properly.</div></div>
<p>Moreover, <code>Groebner.jl</code> can help converting a parametric curve representation to an implicit one. Say, we have a parametrization of <em>the circle on a plane</em></p>
\[
x = \frac{1 - t^2}{1 + t^2} ~~~~ y = \frac{2t}{1 + t^2}
\]

and we want to produce an implicit curve equation in $x, y$ and *without t*.

First, let's clear denominators

\[
t^2y - 2t + y = 0 ~~~~ t^2x + t^2 + x - 1 = 0
\]
<p>~ y = \frac{2t}{1 + t^2}
\]

and we want to produce an implicit curve equation in $x, y$ and *without t*.

First, let's clear denominators

\[
t^2y - 2t + y = 0 ~ t^2x &#43; t^2 &#43; x - 1 &#61; 0 &#93;</p>
<p>The Groebner basis of the above with \(t > x > y\) in lexicographic order is</p>
<pre><code class="language-julia">using AbstractAlgebra
_, &#40;t, x, y&#41; &#61; PolynomialRing&#40;QQ, &#91;&quot;t&quot;, &quot;x&quot;, &quot;y&quot;&#93;, ordering&#61;:lex&#41;

groebner&#40;&#91;t^2*y - 2t &#43; y, t^2*x &#43; t^2 &#43; x - 1&#93;&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x^2 + y^2 - 1
 t*y + x - 1
 t*x + t - y</code></pre>
<p>There, the only two-variable equation in \(x, y\) is</p>
\[
x^2 + y^2 - 1 = 0
\]
<p>Hence, \(x^2 + y^2 - 1 = 0\) is an implicit formula we were looking for. Indeed, for any \(t\) every \((x, y)\) lies on the circle as expected.</p>
<h2 id="solving_systems"><a href="#solving_systems" class="header-anchor">Solving Systems</a></h2>
<p>Groebner bases can be used to solve systems <em>exactly</em>, given the number of solutions is finite.</p>
<p>In this section we assume the usual lexicographic ordering of variables and consider the case with three variables &#40;i.e, \(x > y > z\)&#41;. Same method generalizes naturally for \(n\) indeterminates.</p>
<pre><code class="language-julia">_, &#40;x, y, z&#41; &#61; PolynomialRing&#40;QQ, &#91;&quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#93;, ordering&#61;:lex&#41;;</code></pre>
<p>To illustrate the method, we consider the following polynomial system to solve</p>
<pre><code class="language-julia">system &#61; &#91;x &#43; y &#43; z,
          x*y &#43; x*z &#43; y*z,
          x*y*z - 1&#93;;</code></pre>
<p>Recall that the solutions of a system coincide with zeros of a Groebner basis of this system &#40;since the original system and its basis are <em>equivalent</em>&#41;. Let&#39;s calculate a Groebner basis then&#33;</p>
<pre><code class="language-julia">groebner&#40;system&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 z^3 - 1
 y^2 + y*z + z^2
 x + y + z</code></pre>
<p>Notice that <code>z^3 - 1</code> in the basis is a <em>univariate equation</em>. Solving it over the desired domain one obtains some roots <code>z &#61; ...</code>.</p>
<p>Then, substitute <code>z</code> into the second equation <code>y^2 &#43; y*z &#43; z^2</code>, which in turn becomes univariate in variable <code>y</code>. Solving it and obtaining zeros in <code>y</code>, one moves to the next equation in the basis.</p>
<p>Substituting each <code>y</code> and <code>z</code> to <code>x &#43; y &#43; z</code>, one easily produces a single solution in <code>x</code> for each solution in <code>y, z</code>.  </p>
<p>Solving general polynomial systems &#40;assuming the set of solutions is finite&#41; using Groebner bases relies on the same technique:</p>
<ol>
<li><p>In the Groebner basis there is a univariate equation;</p>
</li>
<li><p>Solve it, and substitute found roots into other equations;</p>
</li>
<li><p>Go to 1.</p>
</li>
</ol>
<p>WIP. For the implementation of symbolic system solving check out <code>roots</code> in <code>Symbolics.jl</code> &#33;</p>
<h2 id="integer_programming"><a href="#integer_programming" class="header-anchor">Integer Programming</a></h2>
<p>Integer programming is the problem of solving linear equations where the solution must be in non-negative integers and should minimize a given &quot;cost function&quot;.</p>
<p>Our strategy here is to convert the integer programming problem into a problem about polynomials, and then solve this polynomial problem using Groebner bases.</p>
<p><em>The classic example problem is the following.</em> Say we have coins of 4 nominal values: pennies \(P\), nickels \(N\), dimes \(D\), and quarters \(Q\). We want to pick a collection that amounts to 117 using the least number of coins possible.</p>
<p>In other words, minimize \(P + N + D + Q\) subject to \(P, N, D, Q \ge 0\) and</p>
\[
P + 5N + 10D + 25Q = 117
\]
<p>The minimal integer solution is \((P, N, D, Q) = (2, 1, 1, 4)\), let&#39;s try to find it with Groebner bases.</p>
<p>First, we will represent each collection of coins by a polynomial \(p^an^bd^cq^d\) in variables \(p, n, d, q\) &#40;e.g., 2 pennies with 5 dimes is \(p^2d^5\)&#41;.</p>
<p>We also know that \(p^5\) is the same as \(n\), \(p^{10}\) is the same as \(d\), and so on. The full set of constraints is</p>
\[
F = \{p^5 - n, p^10 - d, p^25 - q\}
\]
<p>The idea is to construct a more useful set of constraints using a Groebner basis</p>
<pre><code class="language-julia">_, &#40;p, n, d, q&#41; &#61; PolynomialRing&#40;QQ, &#91;&quot;p&quot;,&quot;n&quot;,&quot;d&quot;,&quot;q&quot;&#93;, ordering&#61;:deglex&#41;

F &#61; &#91;p^5 - n, p^10 - d, p^25 - q&#93;   # initial constraints

G &#61; groebner&#40;F&#41;   # more nice and useful constraints</code></pre><pre><code class="plaintext code-output">4-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 n^2 - d
 d^3 - n*q
 n*d^2 - q
 p^5 - n</code></pre>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">Notice we construct polynomials in <code>deglex</code> ordering, instead of the default <code>lex</code>.</div></div>
<p>These new constraints express a useful set of replacement &#40;rewrite&#41; rules. E.g., the expression <code>d^3 - n*q</code> in the basis translates to: replace 3 dimes with a nickel and a quarter.</p>
<p>Now, we take an arbitrary solution &#40;not necessarily minimal&#41;, say \(p^{17}n^{10}d^5\), and compute the normal form w.r.t. \(G\)</p>
<pre><code class="language-julia">normalform&#40;G, p^17*n^10*d^5&#41;</code></pre><pre><code class="plaintext code-output">p^2*n*d*q^4</code></pre>
<p>to obtain the minimial solution \((P, N, D, Q) = (2, 1, 1, 4)\).</p>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">This cool application is copied from <a href="https://people.math.carleton.ca/~cingalls/studentProjects/alithesis.pdf">Christopher Hillar &#40;MSRI&#41; presentation</a> on Groebner Bases.</div></div>
<h2 id="graph_coloring"><a href="#graph_coloring" class="header-anchor">Graph Coloring</a></h2>
<p>In graph theory, Graph coloring is a problem of assigning a color to each vertex of a graph in a way that no two neighboring vertices the same color.</p>


<img src="/Groebner.jl/assets/tutorial/code/output/graph2.svg" alt="">
<p>The common hard question is <em>the existence of a proper coloring with \(k\) colors</em> for \(k > 2\). In this section, we will show how the question can be tackled using the Groebner bases approach.</p>
<p>The approach is to</p>
<ul>
<li><p>Establish relation between <em>k-coloring</em> and <em>system of polynomial equations</em></p>
</li>
<li><p>Solve the system or prove unsolvable</p>
</li>
</ul>
<p>There are two types of polynomials forming a typical graph coloring system.</p>
<p>First, for each vertex \(j\) in a graph we assign variable \(x_j\). To fix that each particular vertex \(j\) has a color we construct <em>vertex polynomials</em> of form</p>
\[
x_j^k - 1 = 0
\]
<p>for each vertex \(j\). Then one color out of \(k\) is represented as one of the \(k\)-th roots of unity.</p>
<p>Secondly, we add <em>edge polynomials</em></p>
\[
\frac{x_i^k - x_j^k}{x_i - x_j}
\]
<p>for each \(i \rightarrow j\) in edges to ensure two neighboring vertices do not share the same color. Such polynomial disallows that colors \(x_i\) and \(x_j\) for two neighbors \(i\) and \(j\) coincide. Finally, solutions of a system constructed this way correspond to proper k-colorings in a 1 to 1 relation.</p>
<p>For example, the coloring system for k&#61;3 in the graph above must contain vertex polynomials</p>
\[
\{ x_1^3 - 1,~ x_2^3 - 1,~ x_3^3 - 1,~ x_4^3 - 1 \}
\]
<p>and a bunch of edge polynomials. Note that adding an edge polynomial \(\frac{x_i^3 - x_j^3}{x_i - x_j}\) to a system is equivalent to adding \(x_i^2 + x_ix_j + x_j\) to it.</p>
<p>Now consider the resulting coloring system for the graph from the picture</p>
<pre><code class="language-julia">_, &#40;x1, x2, x3, x4&#41; &#61; QQ&#91;&quot;x1&quot;,&quot;x2&quot;,&quot;x3&quot;,&quot;x4&quot;&#93;

coloring_system &#61; &#91;
  x1^3 - 1, x2^3 - 1, x3^3 - 1, x4^3 - 1,
  x1^2 &#43; x1*x2 &#43; x2^2,
  x1^2 &#43; x1*x3 &#43; x3^2,
  x1^2 &#43; x1*x4 &#43; x4^2,
  x2^2 &#43; x2*x3 &#43; x3^2,
  x3^2 &#43; x3*x4 &#43; x4^2
&#93;

groebner&#40;coloring_system&#41;</code></pre><pre><code class="plaintext code-output">4-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x4^3 - 1
 x3^2 + x3*x4 + x4^2
 x2 - x4
 x1 + x3 + x4</code></pre>
<p>From the <code>x2 - x4</code> equation in the basis we understand 2nd and 4th vertices should be of the same color. It only remains to assign colors to the remaining vertices</p>

<img src="/Groebner.jl/assets/tutorial/code/output/graphcolored.svg" alt="">
<div class="page-foot">
  <div class="copyright">
    &copy; Alexander Demin. Last modified: February 19, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
        <script src="/Groebner.jl/libs/katex/katex.min.js"></script>
<script src="/Groebner.jl/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        <script src="/Groebner.jl/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
