<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/Groebner.jl/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/Groebner.jl/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/Groebner.jl/css/franklin.css">
<link rel="stylesheet" href="/Groebner.jl/css/poole_hyde.css">
<link rel="stylesheet" href="/Groebner.jl/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/Groebner.jl/assets/favicon.png">

   <title>Groebner.jl — Tutorial</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/Groebner.jl/">Groebner<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/Groebner.jl/">Home</a>
      <!-- <a class="sidebar-nav-item {{ispage tutorial.html}}active{{end}}" href="/Groebner.jl/tutorial/">Tutorials</a> -->
      <li class="sidebar-nav-item active"><a href="/Groebner.jl/tutorial/">• Tutorials</a>
			  <ul class="menu-list-child-list ">
				<li class="menu-list-item active"><a href="/Groebner.jl/tutorial/" class="menu-list-link">Tutorials</a>
				<!-- <li class="menu-list-item {{ispage index.html}}active{{end}}"><a href="/Groebner.jl/tutorial/" class="menu-list-link">Page structure</a> -->
			  </ul>
      <a class="sidebar-nav-item " href="/Groebner.jl/interface/">Interface</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/sumiya11/Groebner.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="tutorials"><a href="#tutorials" class="header-anchor">Tutorials</a></h1>

<h2 id="intro"><a href="#intro" class="header-anchor">Intro</a></h2>
<p>Introduced by Buchberger in 1965 for handling quotient space of Ideals algorithmically, Groebner bases are excellent for <strong>variable elimination, system solving</strong>, and many more. Among others, Groebner bases find applications in</p>
<ul>
<li><p>Robotics</p>
</li>
<li><p>Chemical Reactions Networks Analysis</p>
</li>
<li><p>Control Theory</p>
</li>
<li><p>Cryptography</p>
</li>
</ul>
<p>The following tutorials will give a short introduction to Groebner basis ground theory, and cover some random interesting showcases.</p>
<h2 id="note_on_the_implementation"><a href="#note_on_the_implementation" class="header-anchor">Note on the Implementation</a></h2>
<p>Computing Groebner bases largely depends on a single iterative algorithm, known as <strong>Buchbergers algorithm</strong>. Modified and optimized versions of this algorithm are crucial for many Computer Algebra Systems &#40;<em>e.g., Singular, Maple, Mathematica, Sage</em>&#41;.</p>
<p>The Buchbergers algorithm is exponential by its nature, so a variety of insights, heuristics, and good software engineering practices is required to produce a usable implementation.   </p>
<p>Our package implements <strong>F4 algorithm</strong>, which is a modification of the Buchbergers. The performance of the implementation comes from thoughtful polynomial representation, monomial hashing, lightning-fast linear algebra, and technical modular algorithms.</p>
<p>It&#39;s important to mention that a lot of implementation insights we use in this package were introduced by Jérémy Berthomieu, Christian Eder and Mohab Safey El Din in <a href="https://arxiv.org/abs/2104.03572">&#91;1&#93;</a>.</p>
<p>TODO: split the following into separate pages.</p>
<h2 id="so_what_is_a_groebner_basis"><a href="#so_what_is_a_groebner_basis" class="header-anchor">So, what is a Groebner basis?</a></h2>
<p>A set of polynomials \(F = \{f_1, \ldots, f_m \}\) generates an <strong>infinite</strong> set \(I\):</p>
\[
  I = \{ f_1h_1 + f_2h_2 + \ldots + f_nh_n ~|~ h_i ~are~arbitrary~polynomials \}
\]
<p>Then a Groebner basis of \(F\) is a nicer set of generators for \(I\).</p>
<pre><code class="language-julia">using AbstractAlgebra
_, &#40;x, y&#41; &#61; QQ&#91;&quot;x&quot;, &quot;y&quot;&#93;
F &#61; &#91;x^3 &#43; y^2, x*y &#43; x^2&#93;;</code></pre>
<p>In our example, the Groebner basis F is</p>
<pre><code class="language-julia">using Groebner
G &#61; groebner&#40;F&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 y^3 - y^2
 x*y^2 + y^2
 x^2 + x*y</code></pre>
<p>Every set of polynomials &#40;except for zero&#41; has a Groebner basis.</p>
<p>Given a set of polynomials F, computing a Groebner basis of F is hard. However, it possess a plenty of nice properties.</p>
<p>First of all, the reduced Groebner basis <em>is unique</em>&#33; That is, if two sets \(F_1\) and \(F_2\) generate same sets \(I_1, I_2\) then Groebner bases of \(F_1\) and \(F_2\) are the same</p>
<pre><code class="language-julia"># Here, F₁ and F₂ generate the same infinite polynomial sets
F₁ &#61; &#91;x^3 &#43; y^3, x*y &#43; x^2, x^3 - y^2&#93;
F₂ &#61; &#91;x^3 - y^2, x*y &#43; x^2&#93;
groebner&#40;F₁&#41; &#61;&#61; groebner&#40;F₂&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>Secondly, Groebner bases enable an algorithmic way to do <em>multivariate polynomial division by a set</em>. With a polynomial \(f\) and a set of polynomials \(G\), we can divide \(f\) by \(G\) by computing <em>the</em> normal form of \(f\) w.r.t. \(G\).</p>
<p><code>Groebner.jl</code> provides normal form functionality with the <code>normalform</code> function.</p>
<pre><code class="language-julia">F &#61; &#91;x^3 &#43; y^2, x*y &#43; x^2&#93;
f &#61; x^4*y^2 &#43; y^3 &#43; x^2 &#43; x*y &#43; 1

G &#61; groebner&#40;F&#41;     # compute the basis
normalform&#40;G, f&#41;    # divide f by G</code></pre><pre><code class="plaintext code-output">2*y^2 + 1</code></pre>
<p>The normal form with respect to a Groebner basis is unique, and has in turn nice properties. We will discuss these in the following.</p>
<h2 id="useful_analogies"><a href="#useful_analogies" class="header-anchor">Useful Analogies</a></h2>
<h3 id="groebner_basis_is_gaussian_elimination"><a href="#groebner_basis_is_gaussian_elimination" class="header-anchor">Groebner basis is Gaussian Elimination</a></h3>
<p>Groebner bases can be seen as <em>a nonlinear generalization</em> of <strong>Gaussian elimination</strong> for systems of algebraic equations. Applied to a linear system, Groebner basis algorithms produce exactly row echelon matrix form&#33;</p>
<pre><code class="language-julia">using DynamicPolynomials

@polyvar x y z
system &#61; &#91;
       x - y &#43; z &#43; 1,
       x &#43; 2y &#43; 3z &#43; 4,
       x &#43; y &#43; 5z &#43; 3
&#93;

groebner&#40;system&#41;  # rref</code></pre><pre><code class="plaintext code-output">3-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 z
 y + 1
 x + 2</code></pre>
<h3 id="groebner_basis_is_euclidean_algorithm"><a href="#groebner_basis_is_euclidean_algorithm" class="header-anchor">Groebner basis is Euclidean Algorithm</a></h3>
<p>Another important property is that a Groebner basis of a <em>univariate Ideal</em> is nothing else but GCD of its generators.</p>
<pre><code class="language-julia">using DynamicPolynomials

@polyvar x
f &#61; &#40;x^2 - 1&#41;^7*&#40;x &#43; 3&#41;*&#40;x - 7&#41;^4
g &#61; &#40;x &#43; 3&#41;*&#40;x &#43; 7&#41;

groebner&#40;&#91;f, g&#93;&#41;   # gcd by groebner</code></pre><pre><code class="plaintext code-output">1-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 x + 3</code></pre>
<pre><code class="language-julia">gcd&#40;f, g&#41;          # usual gcd</code></pre><pre><code class="plaintext code-output">x + 3</code></pre>
<p>So, you can compute the GCD of several polynomials at once using <code>Groebner.jl</code>&#33; But probably you shouldn&#39;t..</p>
<p>We emphasize, however, that <code>Groebner.jl</code> is designed to have as little runtime overhead as possible</p>
<pre><code class="language-julia">h &#61; &#40;x &#43; 3&#41;^5

@btime gcd&#40;gcd&#40;&#36;f, &#36;g&#41;, &#36;h&#41;</code></pre><pre><code class="plaintext code-output">  321.603 μs (3816 allocations: 228.98 KiB)
x + 3</code></pre>
<pre><code class="language-julia">F &#61; &#91;f, g, h&#93;
@btime groebner&#40;&#36;F&#41;</code></pre><pre><code class="plaintext code-output">  110.501 μs (1160 allocations: 127.61 KiB)
1-element Vector{DynamicPolynomials.Polynomial{true, Int64}}:
 x + 3</code></pre>
<h2 id="variable_elimination"><a href="#variable_elimination" class="header-anchor">Variable Elimination</a></h2>
<p>With appropriate term orders, one can use Grobner bases to <em>eliminate indeterminates</em> from equations. The main observation here is</p>
<p>If \(G\) is a Groebner basis for some Ideal \(I\) w.r.t. <code>lex</code> order with \(x > y > z\) then</p>
\[
G \cap R[y, z]
\]
<p>is a Groebner basis for \(I_{y, z}~ =~ I \cap R[y, z]\). Here, one can see \(I_{y, z}\) as a geometric projection of solutions of \(I\) onto the last two variables.</p>
<p>For example, consider polynomials in three variables \(x > y > z\)</p>
<pre><code class="language-julia">_, &#40;x, y, z&#41; &#61; QQ&#91;&quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#93;

F &#61; &#91;x^2 &#43; y &#43; z - 1,
     x &#43; y^2 &#43; z - 1,
     x &#43; y &#43; z^2 - 1&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x^2 + y + z - 1
 x + y^2 + z - 1
 x + y + z^2 - 1</code></pre>
<p>Groebner basis is</p>
<pre><code class="language-julia">G &#61; groebner&#40;F&#41;</code></pre><pre><code class="plaintext code-output">4-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 z^6 - 4*z^4 + 4*z^3 - z^2
 y*z^2 + 1//2*z^4 - 1//2*z^2
 y^2 - y - z^2 + z
 x + y + z^2 - 1</code></pre>
<p>Notice that first three polynomials <code>G&#91;1:3&#93;</code> do not contain <code>x</code>. That means the <code>G&#91;1:3&#93;</code> is a Groebner basis for \(I_{y, z}\)</p>
<h2 id="curve_implicitization"><a href="#curve_implicitization" class="header-anchor">Curve Implicitization</a></h2>
<p>Say we have a parametrization of the circle as</p>
\[
x = \frac{1 - t^2}{1 + t^2} ~~~ y = \frac{2t}{1 + t^2}
\]

Let's clear denominators

\[
t^2y - 2t + y = 0 ~~~ t^2x + t^2 + x - 1 = 0
\]
<p> y = \frac{2t}{1 + t^2}
\]

Let's clear denominators

\[
t^2y - 2t + y = 0  t^2x &#43; t^2 &#43; x - 1 &#61; 0 &#93;</p>
<p>Groebner basis in <code>lex</code> order \(t > x > y\) is</p>
<pre><code class="language-julia">_, &#40;t, x, y&#41; &#61; QQ&#91;&quot;t&quot;, &quot;x&quot;, &quot;y&quot;&#93;

groebner&#40;&#91;t^2*y - 2t &#43; y, t^2*x &#43; t^2 &#43; x - 1&#93;&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x^2 + y^2 - 1
 t*y + x - 1
 t*x + t - y</code></pre>
<p>We see that \(I_{x, y}\) &#61; &#123; x^2 &#43; y^2 - 1 &#125;, so for any \(t\) every \((x, y)\) lies on the circle as expected.</p>
<h2 id="solving_systems"><a href="#solving_systems" class="header-anchor">Solving Systems</a></h2>
<p>In this section we will assume <code>lex</code> term ordering and consider the case with three variables. Same generalizes naturally for \(n\) indeterminates.</p>
<pre><code class="language-julia">_, &#40;x, y, z&#41; &#61; QQ&#91;&quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#93;;</code></pre>
<p>Say we have a polynomial system to solve <em>exactly &#40;symbolically&#41;</em></p>
\[
\begin{aligned}
x + y + z &= 0 \\
xy + xz + yz &= 0 \\
xyz - 1 &= 0 \\
\end{aligned}
\]
<pre><code class="language-julia">sys &#61; &#91;x &#43; y &#43; z,
       x*y &#43; x*z &#43; y*z,
       x*y*z - 1&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x + y + z
 x*y + x*z + y*z
 x*y*z - 1</code></pre>
<p>Computing Groebner basis results in</p>
<pre><code class="language-julia">groebner&#40;sys&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 z^3 - 1
 y^2 + y*z + z^2
 x + y + z</code></pre>
<p>Notice that <code>x^3 - 1</code> in the basis is a <em>univariate equation</em>&#33; Solving it over reals we obtain some roots <code>z &#61; ...</code>.</p>
<p>Then substitute these known <code>z</code> into the second equation <code>y^2 &#43; y*z &#43; z^2</code>, which in turn becomes univariate in <code>y</code>.</p>
<p>Obtaining zeros in <code>y</code>, we move to the next equation in the basis.  </p>
<p>Solving polynomial systems in general using Groebner bases relies on the same technique:</p>
<ol>
<li><p>There is a univariate equation in Groebner basis</p>
</li>
<li><p>Solve it, and substitute found roots into other equations</p>
</li>
<li><p>goto 1.</p>
</li>
</ol>
<p>For the implementation of symbolic system solving check out <code>roots</code> in <code>Symbolics.jl</code> &#33;</p>
<h2 id="graph_coloring"><a href="#graph_coloring" class="header-anchor">Graph Coloring</a></h2>
<p>In graph theory, Graph coloring is a problem of assigning a color to each vertex of a graph in a way that no two neighboring vertices the same color.</p>
<pre><code class="plaintext code-output">true</code></pre>
<pre><code class="language-julia">gplot&#40;g&#41;</code></pre><pre><code class="plaintext code-output">Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), Compose.UnitBox{Float64, Float64, Float64, Float64}(-1.2, -1.2, 2.4, 2.4, 0.0mm, 0.0mm, 0.0mm, 0.0mm), nothing, nothing, nothing, List([Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([Compose.Form{Compose.LinePrimitive}(Compose.LinePrimitive[Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.8462288176251946cx, 0.12837379535464477cy), (0.9831214069347733cx, -0.8761447897901001cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.7103719018026927cx, 0.21389939933299507cy), (-0.6877553297542488cx, -0.2365159789078891cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.7136435702045926cx, 0.2995256242374019cy), (-0.8842933456446246cx, 0.9527033813271427cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.8839949799768714cx, -0.9534399814279083cy), (-0.6907286324883954cx, -0.32140560371153043cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(-0.8254695527429687cx, -0.1512576972113842cy), (-0.9812640997685553cx, 0.8764121120719455cy)])], Symbol(""))]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(1.5mm)]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.8274509803921568,0.8274509803921568,0.8274509803921568,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(1.5mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.8274509803921568,0.8274509803921568,0.8274509803921568,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.FontSizePrimitive}(Compose.FontSizePrimitive[Compose.FontSizePrimitive(4.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([Compose.Form{Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}}(Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}[Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((0.829350224559968cx, 0.25222900556454464cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((1.0cx, -1.0cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((-0.8067336525115241cx, -0.2748455851394387cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((-1.0cx, 1.0cy), 0.05w)], Symbol(""))]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(0.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.25098039215686274,0.8784313725490196,0.8156862745098039,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.FontSizePrimitive}(Compose.FontSizePrimitive[Compose.FontSizePrimitive(4.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol(""))]), List([]), List([]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol(""))</code></pre>
<p>The common hard question is <em>the existence of a proper coloring with \(k\) colors</em> for \(k > 2\). In this section, we will show how the question can be tackled using the Groebner bases approach.</p>
<p>The approach is to</p>
<ul>
<li><p>Establish relation between <em>k-coloring</em> and <em>system of polynomial equations</em></p>
</li>
<li><p>Solve the system or prove unsolvable</p>
</li>
</ul>
<p>There are two types of polynomials forming a typical graph coloring system.</p>
<p>First, for each vertex \(j\) in a graph we assign variable \(x_j\). To fix that each particular vertex \(j\) has a color we construct <code>vertex polynomials</code> of form</p>
\[
x_j^k - 1 = 0
\]
<p>for each vertex \(j\). Then one color out of \(k\) is represented as one of the \(k\)th-roots of unity.</p>
<p>Secondly, we must add \(edge polynomials\) polynomials</p>
\[
\frac{x_i^k - x_j^k}{x_i - x_j}
\]
<p>for each \(i \rightarrow j\) in edges to ensure two neighboring vertices do not share the same color. Such polynomial disallows that colors \(x_i\) and \(x_j\) for two neighbors \(i\) and \(j\) coincide.</p>
<p>Finally, solutions of a system constructed this way correspond to proper k-colorings in a 1 to 1 relation.</p>
<pre><code class="language-julia">gplot&#40;g&#41;</code></pre><pre><code class="plaintext code-output">Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), Compose.UnitBox{Float64, Float64, Float64, Float64}(-1.2, -1.2, 2.4, 2.4, 0.0mm, 0.0mm, 0.0mm, 0.0mm), nothing, nothing, nothing, List([Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([Compose.Form{Compose.LinePrimitive}(Compose.LinePrimitive[Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(-0.05873685307444318cx, -0.9255275589190896cy), (-0.8996064966272701cx, -0.3017659320962919cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.03556732506098626cx, -0.8751484076266771cy), (-0.04979903965480808cx, 0.8751484076266771cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.11846152007199319cx, -0.9013794545794641cy), (0.9231951302262935cx, 0.13193090432727506cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(-0.923784140470636cx, -0.12821704196617376cy), (-0.13210422442147254cx, 0.9009235509507924cy)]), Compose.LinePrimitive{Tuple{Measures.Measure, Measures.Measure}}(Tuple{Measures.Measure, Measures.Measure}[(0.045133981312356644cx, 0.9263828446125144cy), (0.898977653795535cx, 0.30416860513529653cy)])], Symbol(""))]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(1.5mm)]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.8274509803921568,0.8274509803921568,0.8274509803921568,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(1.5mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.8274509803921568,0.8274509803921568,0.8274509803921568,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.FontSizePrimitive}(Compose.FontSizePrimitive[Compose.FontSizePrimitive(4.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([Compose.Form{Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}}(Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}[Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((0.04165665029828669cx, -1.0cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((-1.0cx, -0.22729349101538143cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((-0.055888364892108466cx, 1.0cy), 0.05w), Compose.CirclePrimitive{Tuple{Measures.Measure, Measures.Measure}, Measures.Measure}((1.0cx, 0.23055144974781094cy), 0.05w)], Symbol(""))]), List([Compose.Property{Compose.LineWidthPrimitive}(Compose.LineWidthPrimitive[Compose.LineWidthPrimitive(0.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.25098039215686274,0.8784313725490196,0.8156862745098039,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol("")), Compose.Context(Measures.BoundingBox{Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}, Tuple{Measures.Length{:w, Float64}, Measures.Length{:h, Float64}}}((0.0w, 0.0h), (1.0w, 1.0h)), nothing, nothing, nothing, nothing, List([]), List([]), List([Compose.Property{Compose.FontSizePrimitive}(Compose.FontSizePrimitive[Compose.FontSizePrimitive(4.0mm)]), Compose.Property{Compose.StrokePrimitive}(Compose.StrokePrimitive[Compose.StrokePrimitive(RGBA{Float64}(0.0,0.0,0.0,0.0))]), Compose.Property{Compose.FillPrimitive}(Compose.FillPrimitive[Compose.FillPrimitive(RGBA{Float64}(0.0,0.0,0.0,1.0))])]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol(""))]), List([]), List([]), 0, false, false, false, false, nothing, nothing, 0.0, Symbol(""))</code></pre>
<p>The coloring system for k&#61;3 in the graph above must contain vertex polynomials</p>
\[
x_1^3 - 1, x_2^3 - 1, x_3^3 - 1, x_4^3 - 1
\]
<p>and a bunch of edge polynomials. Note that adding \(\frac{x_i^3 - x_j^3}{x_i - x_j}\) to a system is equivalent to adding \(xi^2 + x_ix_j + x_j\).</p>
<pre><code class="language-julia">_, &#40;x1, x2, x3, x4&#41; &#61; QQ&#91;&quot;x1&quot;,&quot;x2&quot;,&quot;x3&quot;,&quot;x4&quot;&#93;

coloring_system &#61; &#91;
  x1^3 - 1, x2^3 - 1, x3^3 - 1, x4^3 - 1,
  x1^2 &#43; x1*x2 &#43; x2^2,
  x1^2 &#43; x1*x3 &#43; x3^2,
  x1^2 &#43; x1*x4 &#43; x4^2,
  x2^2 &#43; x2*x3 &#43; x3^2,
  x3^2 &#43; x3*x4 &#43; x4^2
&#93;

groebner&#40;coloring_system&#41;</code></pre><pre><code class="plaintext code-output">4-element Vector{AbstractAlgebra.Generic.MPoly{Rational{BigInt}}}:
 x4^3 - 1
 x3^2 + x3*x4 + x4^2
 x2 - x4
 x1 + x3 + x4</code></pre>
<div class="page-foot">
  <div class="copyright">
    &copy; Alexander Demin. Last modified: May 02, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
        <script src="/Groebner.jl/libs/katex/katex.min.js"></script>
<script src="/Groebner.jl/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        <script src="/Groebner.jl/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
