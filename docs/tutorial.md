
@def title = "Groebner.jl — Tutorial"
@def hasmath = false
@def hascode = true
<!-- Note: by default hasmath == true and hascode == false. You can change this in
the config file by setting hasmath = false for instance and just setting it to true
where appropriate -->

# Tutorials

```julia:installs
import Pkg # hide
import Pkg; Pkg.add("BenchmarkTools") # hide
Pkg.add("AbstractAlgebra") # hide
Pkg.add("Groebner") # hide
Pkg.add("DynamicPolynomials") # hide
using Groebner # hide
using AbstractAlgebra # hide
using BenchmarkTools # hide
```

## Intro

Introduced by Buchberger in 1965 for handling quotient space of Ideals algorithmically, Groebner bases are excellent for **variable elimination, system solving**, and many more. Among others, Groebner bases find applications in

- Robotics
- Chemical Reactions Networks Analysis
- Control Theory
- Cryptography

The following tutorials will give a short introduction to Groebner basis ground theory, and cover some random interesting showcases.

## Note on the Implementation

Computing Groebner bases largely depends on a single iterative algorithm, known as **Buchbergers algorithm**. Modified and optimized versions of this algorithm are crucial for many Computer Algebra Systems (*e.g., Singular, Maple, Mathematica, Sage*).

The Buchbergers algorithm is **triple-exponential** by its nature, so a variety of insights, heuristics, and good software engineering practices is required to produce a usable implementation.   

Our package implements **F4 algorithm**, which is a modification of the Buchbergers. The performance of the implementation comes from thoughtful polynomial representation, monomial hashing, lightning-fast linear algebra, and technical modular algorithms.

It's important to mention that a lot of implementation insights we use in this package were introduced by Jérémy Berthomieu, Christian Eder and Mohab Safey El Din in [[1]](https://arxiv.org/abs/2104.03572).

TODO: split the following into separate pages.
TODO: check out `math mode`

# So, what is a Groebner basis?

Groebner bases go inseparable from polynomial Ideals. If we have a set of polynomials F = \{f₁, … fₘ\}, the Ideal I = ⟨F⟩ *generated by* F is

\[
  I = \{ smth\}
\]

which is exactly *all polynomials produced as combinations* of elements of F with polynomial coefficients.

```julia:aaimport
using AbstractAlgebra
R, (x, y) = PolynomialRing(QQ, [:x, :y])
F = [x^3 + y^2, x*y + x^2];
# the Ideal generated by F
# would contain p₁F[1] + p₂F[2] for all possible pᵢ
```

A Groebner basis for Ideal I is a *nicer representation* of its generators F. Namely,
- If set of polynomials G *generates the same ideal* as F, i.e. I = ⟨G⟩ = ⟨F⟩
- And *leading Ideals coincide*, so that  ⟨leading_terms(G)⟩ = ⟨leading_terms(I)⟩

Then G is a Groebner basis for I. It is important that every Ideal (except for zero) has a Groebner basis!

In our example, the Groebner basis and leading Ideal of ⟨F⟩ are
```julia:exampleone
using Groebner
G = groebner(F)
println("Basis is $G \nLeading Ideal is $(map(leading_term, G))")
```

Given a set of polynomials F, computing a Groebner basis of F is hard. However, it possess a plenty of nice properties.

First of all, the reduced Groebner basis **is unique**! That is, ⟨F₁⟩ = ⟨F₂⟩ iff Groebner bases of ⟨F₁⟩ and ⟨F₂⟩ are the same. `Groebner.jl` computes the reduced basis by default.


```julia:unique
# Here, F₁ and F₂ generate the same Ideal
F₁ = [x^3 + y^3, x*y + x^2, x^3 - y^2]
F₂ = [x^3 - y^2, x*y + x^2]
groebner(F₁) == groebner(F₂)
```

Secondly, Groebner bases enable a proper definition of a *multivariate polynomial division by a set*. With polynomials f and g, we can divide f by g. Groebner bases make it possible to *divide f by a whole set* G!

TODO: does not work due to a known normalform issue

```julia:nf
F = [x^3 + y^2, x*y + x^2]
f = x^4*y^2 + y^3 + x^2 + x*y + 1

G = groebner(F)     # compute the basis
normalform(G, f)    # divide f by G
```

TODO: add more

# Useful Analogies

Because Groebner bases algorithms may be considered as *nonlinear generalizations of Gaussian elimination* for systems of linear equations, they have very widespread applicability.

## Groebner basis is Gaussian Elimination

Applied to a *linear system*, Groebner basis algorithms produce exactly row echelon form!

```julia:gauss
using DynamicPolynomials

@polyvar x y z
system = [
       x - y + z + 1,
       x + 2y + 3z + 4,
       x + y + 5z + 3
]

groebner(system)
```

## Groebner basis is GCD

It's an intriguing property, that a Groebner basis of a *univariate Ideal* is nothing else but GCD of its generators.

```julia:gcd1
using DynamicPolynomials

@polyvar x
f = (x^2 - 1)^7*(x + 3)*(x - 7)^4
g = (x + 3)*(x + 7)

gcd(f, g)   # usual gcd
```

```julia:gcd2
groebner([f, g])
```

So, you can compute GCD using `Groebner.jl`! But probably you shouldn't.. `Groebner.jl` converts all input into internal polynomial representation, instantiates huge hashtables and matrices; this all is unnesesarry for computing GCD.

We emphasize, however, that `Groebner.jl` is designed to have as little runtime overhead as possible

```julia:gcd3
@btime gcd($f, $g)
```

```julia:gcd4
F = [f, g]
@btime groebner($F)
```


# Eliminating parameters

TODO!

With appropriate term orders, one can use Grobner
bases to *eliminate indeterminates* from equations.

TODO: add a theoretical note and a pic

Eliminate variable t from:

x = 2t - 4t^3, y = t^2 - 3t^4

```julia:eliminate
R, (t, x, y) = PolynomialRing(QQ, ["t", "x", "y"])
@assert y < x < t

F = [x - 2t + 4t^3, y - t^2 + 3t^4]   # initial system

G = groebner(F)
```

Notice that the first generator in G does not contain t! Thus, equation

x^4 - 16//3*x^2*y - 4//27*x^2 + 256//27*y^3 + 128//27*y^2 + 16//27*y = 0

is precisely equivalent to the original system!


# Solving Systems

For system solving please check out `Symbolics.jl` ! TODO soon

# Graph Coloring

TODO

# Integer Programming

TODO

f = (7x - 1)*(4x + 3)^2*(x^2 + 5x + 13)^5
g = (4x + 3)*(x^3 - x - 1)^3*(x - 2)^2
