
"""
    groebner

    Computes the Groebner basis of the ideal generated by `polys`.

    At the moment only `AbstractAlgebra.MPoly` polynomials are valid input.
    Available orderings are: `degrevlex`.
"""
function groebner(
            polys::Vector{Poly};
            rng::Rng=Random.MersenneTwister(42),
            loglevel::LogLevel=Logging.Info
            ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input polynomials =#
    # copies input, so that polys would not be changed itself
    ring, exps, coeffs = convert_to_internal(polys)

    #= compute the groebner basis =#
    if ring.ch != 0
        # if finite field
        bexps, bcoeffs = groebner_ff(ring, exps, coeffs; rng=rng)
    else
        # if rational coefficients
        bexps, bcoeffs = groebner_qq(ring, exps, coeffs; rng=rng)
    end

    #= revert logger =#
    Logging.global_logger(prev_logger)

    #= convert result back to representation of input =#
    export_basis(parent(first(polys)), bexps, bcoeffs)
end

#=
    Finite field Groebner specialization
=#
function groebner_ff(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{UInt64}};
            rng::Rng=Random.MersenneTwister(42)
            ) where {Rng<:Random.AbstractRNG}

    f4(ring, exps, coeffs, rng)
end

#=
    Rational field Groebner specialization
=#
function groebner_qq(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{Rational{BigInt}}};
            rng::Rng=Random.MersenneTwister(42)
            ) where {Rng<:Random.AbstractRNG}

    # scale coefficients to integer ring inplace
    coeffs_zz = scale_denominators!(coeffs)

    gbcoeffs_accum = Vector{Vector{BigInt}}(undef, 0)
    gbexps = Vector{Vector{Vector{UInt16}}}(undef, 0)
    gbcoeffs_qq = Vector{Vector{Rational{BigInt}}}(undef, 0)

    # reduction moduli
    moduli = Int[ 2^30 + 3 ]
    # modulo = prod(moduli)
    modulo = BigInt(1)

    i = 1
    while true
        prime = last(moduli)

        @info "$i: selected prime $prime"

        # compute the image of coeffs_zz in GF(prime),
        # by coercing each coefficient into the finite field
        ring_ff, coeffs_ff = reduce_modulo(coeffs_zz, ring, prime)

        # groebner basis over finite field ideal
        # TODO: gbexps can be only computed once
        gbexps, gbcoeffs_ff = f4(ring_ff, exps, coeffs_ff, rng)

        # TODO: add majority rule based choice

        # reconstruct basis coeffs into integers
        # from the previously accumulated basis and the new one,
        @info "CRT with ($modulo, $(ring_ff.ch))"
        gbcoeffs_zz, modulo = reconstruct_crt!(
                            gbcoeffs_accum, modulo,
                            gbcoeffs_ff, ring_ff.ch)

        gbcoeffs_accum = gbcoeffs_zz

        # try to reconstruct basis coeffs from integers
        # into rationals
        @info "Reconstructing modulo $modulo"
        gbcoeffs_qq = reconstruct_modulo(gbcoeffs_zz, modulo)

        # run correctness checks to assure the reconstrction is correct
        # TODO: correctness_checks
        if true || correctness_checks(gbexps, gbcoeffs_qq, exps, coeffs)
            @info "Reconstructed successfully!"
            break
        end

        # not correct, goto next prime

        push!(moduli, nextprime(prime + 1))

        i += 1
        if i > 1000
            @error "Something probably went wrong in groebner.."
            return
        end
    end

    gbexps, gbcoeffs_qq
end

#------------------------------------------------------------------------------
