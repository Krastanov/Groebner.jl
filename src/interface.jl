
#######################################

"""
    function groebner(
                polynomials;
                reduced=true,
                ordering=:input,
                certify=false,
                rng=Random.MersenneTwister(42),
                loglevel=Logging.Warn
    )

Computes a Groebner basis of the ideal generated by `polynomials`.

If `reduced` is set, returns the reduced basis, which is **unique**.

Uses the ordering on `polynomials` by default.
If `ordering` parameter is explicitly specialized, it takes precedence.
Possible orderings are

- :input for preserving the input ordering
- :lex for lexicographic
- :deglex for graded lexicographic
- :degrevlex for graded reverse lexicographic

Graded orderings tend to be the fastest.

The algorithm is randomized by default, so the result can be incorrect.
The probability of success is estimated to be TODO.
If guaranteed result is needed, set parameter `certify`.

Set `forsolve` to `true` to tell the algorithm to automatically select parameters
for producing a basis further used in solving an input system. In this case,
the output basis is in generic position in lexicographic monomial order.

Setting `forsolve=true` for an unsolvable system in input will produce a warning.

"""
function groebner(
            polynomials::Vector{Poly};
            reduced::Bool=true,
            ordering::Symbol=:input,
            certify::Bool=false,
            forsolve::Bool=false,
            linearalgebra::Symbol=:exact,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::Logging.LogLevel=Logging.Warn
            ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input polynomials =#
    # Copies input, so that polynomials would not be changed itself.
    ring, exps, coeffs = convert_to_internal(polynomials, ordering)

    #= check and set algorithm parameters =#
    metainfo = set_metaparameters(ring, ordering, certify, forsolve)
    # now ring stores computation ordering
    # metainfo is now a struct to store target ordering

    #= change input ordering if needed =#
    assure_ordering!(ring, exps, coeffs, metainfo)

    #= compute the groebner basis =#
    if ring.ch != 0
        # if finite field
        # Always returns UInt coefficients #
        bexps, bcoeffs = groebner_ff(ring, exps, coeffs, reduced, rng)
    else
        # if rational coefficients
        # Always returns rational coefficients #
        bexps, bcoeffs = groebner_qq(ring, exps, coeffs, reduced, certify, rng)
    end

    # ordering in bexps here matches target ordering in metainfo

    #= revert logger =#
    Logging.global_logger(prev_logger)

    # ring contains ordering of computation, it is the requested ordering
    #= convert result back to representation of input =#
    convert_to_output(ring, polynomials, bexps, bcoeffs)
end

#######################################
# Generic isgroebner


"""
    function isgroebner(
                polynomials::Vector{Poly};
                ordering::Symbol=:input,
                randomized::Bool=true,
                rng::Rng=Random.MersenneTwister(42),
                loglevel::Logging.LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

Checks if `polynomials` forms a Groebner basis.

Uses the ordering on `polynomials` by default.
If `ordering` is explicitly specialized, it takes precedence.
*(On the fly ordering change not implemented yet :D)*

The algorithm is randomized by default, but
this can be changed with the `randomized` param.
*(Derandomized version not implemented yet :D)*

"""
function isgroebner(
            polynomials::Vector{Poly};
            ordering=:input,
            randomized::Bool=true,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input polynomials =#
    # Copies input, so that polys would not be changed itself.
    ring, exps, coeffs = convert_to_internal(polynomials, ordering)

    #= compute the groebner basis =#
    if ring.ch != 0
        # if finite field
        # Always returns UInt coefficients #
        flag = isgroebner_ff(ring, exps, coeffs, rng)
    else
        # if rational coefficients
        # Always returns rational coefficients #
        flag = isgroebner_qq(ring, exps, coeffs, randomized, rng)
    end

    #=
    Assuming ordering of `bexps` here matches `ring.ord`
    =#

    #= revert logger =#
    Logging.global_logger(prev_logger)

    flag
end

#######################################
# Generic normalform

"""
    function normalform(
                basispolys::Vector{Poly},
                tobereduced::Poly;
                ordering::Symbol=:input,
                randomized::Bool=true,
                rng::Rng=Random.MersenneTwister(42),
                loglevel::Logging.LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

Computes the normal form of `tobereduced` w.r.t `basispolys`.
The latter is assumed to be a Groebner basis.

Uses the ordering on `basispolys` by default.
If `ordering` is explicitly specialized, it takes precedence.
*(On the fly ordering change not implemented yet :D)*

The algorithm is randomized by default, but
this can be changed with the `randomized` param.
*(Derandomized version not implemented yet :D)*

"""
function normalform(
            basispolys::Vector{Poly},
            tobereduced::Poly;
            ordering::Symbol=:input,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::LogLevel=Logging.Warn
            ) where {Poly, Rng<:Random.AbstractRNG}

    first(normalform(
            basispolys, [tobereduced],
            ordering=ordering, rng=rng, loglevel=loglevel)
    )
end

function normalform(
            basispolys::Vector{Poly},
            tobereduced::Vector{Poly};
            ordering::Symbol=:input,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::LogLevel=Logging.Warn
            ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input basis polynomials =#
    # Copies input, so that polys would not be changed itself.
    ring1, basisexps, basiscoeffs = convert_to_internal(basispolys, ordering)
    ring2, tbrexps, tbrcoeffs = convert_to_internal(tobereduced, ordering)

    @assert ring1.nvars == ring2.nvars && ring1.ch == ring2.ch && ring1.ord == ring2.ord
    ring = ring1
    # We assume basispolys is already a Groebner basis! #

    #= compute the groebner basis =#
    bexps, bcoeffs = normal_form_f4(
                        ring, basisexps, basiscoeffs,
                        tbrexps, tbrcoeffs, rng)

    #=
    Assuming ordering of `bexps` here matches `ring.ord`
    =#

    #= revert logger =#
    Logging.global_logger(prev_logger)

    # ring contains ordering of computation, it is the requested ordering
    #= convert result back to representation of input =#
    convert_to_output(ring, tobereduced, bexps, bcoeffs)
end
