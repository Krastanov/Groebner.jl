
# The file contains the main algorithm used to compute Groebner bases.
# It composes modular algorithms, fglm, and f4


"""
    Computes the Groebner basis of the ideal generated by given polynomials

    Parameters:
        . fs       - generators of the ideal
        . zerodim  - if the input ideal is zero-dimensional
                  (i.e. originates from a system with finitely many solutions)
        . reduced  - if The reduced Groebner basis to be returned
        . loglevel - sets verbosity level
        . maxpairs - maximal number of pairs selected for one matrix; default is
                      0, i.e. no restriction. If matrices get too big or consume
                      too much memory this is a good parameter to play with.
        . linalg   - linear algebra backend to use

    Supported input orderings:
        . lex
        . degrevlex

    Invariants:
        . Returns in the same ring the input is given
        .
"""
function groebner(
            fs::Vector{MPoly{Rational{BigInt}}};
            zerodim=false,
            reduced=true,
            linalg=:sparse,
            maxpairs=0,
            loglevel=Logging.Debug)

    # I guess we want to init this when initializing the package
    # old_logger     = Logging.current_logger()
    package_logger = Logging.ConsoleLogger(stderr, loglevel)
    Logging.global_logger(package_logger)

    # original ring over QQ
    Qring = parent(first(fs))

    # determine orderings
    initial_ordering = ordering(Qring)
    @assert initial_ordering in (:lex, :degrevlex)
    if initial_ordering == :lex && zerodim || initial_ordering == :degrevlex
        computing_ordering = :degrevlex
    else
        @warn "Fallback to computations in :lex. This could be slow."
        computing_ordering = :lex
    end
    usefglm = initial_ordering == :lex && computing_ordering == :degrevlex

    @debug "orderings" initial_ordering computing_ordering usefglm
    @debug "f4: $linalg linear algebra"
    @debug "fglm: $(:dense) linear algebra"

    # convert polynomials into computing ordering
    fs_ord = change_ordering(fs, computing_ordering)

    # scale polynomials to integer coefficients
    fs_ord_zz = scale_denominators(fs_ord)
    Zring = parent(first(fs_ord_zz))

    # reduction moduli
    moduli = Int[ 2^30 + 3 ]

    T = elem_type(Qring)
    gbs_gf = []
    gb_qq  = T[]

    i = 0
    while true
        prime = last(moduli)

        @debug "selected prime" prime

        # compute the image of fs in GF(prime),
        # by coercing each coefficient into the finite field
        fs_ord_gf = reduce_modulo(fs_ord_zz, prime)

        # groebner basis of the reduced ideal
        gb_ord_gf = f4(fs_ord_gf,
                        reduced=reduced,
                        maxpairs=maxpairs,
                        linalg=linalg)

        # return back to the initial ordering
        if usefglm
            gb_ord_gf = fglm(gb_ord_gf)
        end

        push!(gbs_gf, gb_ord_gf)

        # TODO: add majority rule based choice

        # trying to reconstruct gbs into rationals

        gb_zz_crt, modulo = reconstruct_crt(gbs_gf, moduli, Zring)
        gb_qq = reconstruct_modulo(gb_zz_crt, modulo, Qring)

        @info "gb of $(length(gb_qq)) polys modulo $(prod(BigInt.(moduli)))"

        @debug "running correctness check.."
        if correctness_checks(gb_qq, fs) # TODO
            break
        end

        @debug "reconstruction failed.. starting over"

        push!(moduli, nextprime(prime + 1))

        i += 1
        if i > 1000
            @error "Something probably went wrong in reconstructing in groebner.."
            return
        end
    end

    @info "used $(length(moduli)) primes of total product $(prod(BigInt.(moduli)))"
    @info "resulting basis has $(length(gb_qq)) polynomials"

    # Logging.global_logger(old_logger)
    if reduced
        gb_qq = reducegb(gb_qq)
    end

    gb_qq
end

function groebner(fs::Vector{MPoly{GFElem{Int}}};)
    length(fs) > 0 || error("Empty input")

    R = parent(first(fs))
    ordering(R) in (:degrevlex, ) || error("Only :degrevlex is supported")

    f4(fs)
end

# Checks if the given polynomial set gb_reconstructed
# is indeed a Groebner basis for the ideal generated by initial_gens
function correctness_checks(gb_reconstructed, initial_gens)
    is_groebner(gb_reconstructed, initial_gens=initial_gens)
end

#------------------------------------------------------------------------------
