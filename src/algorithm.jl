
#######################################

"""
    function groebner(
                polynomials::Vector{Poly};
                reduced::Bool=true,
                ordering::Symbol=:input,
                randomized::Bool=true,
                rng::Rng=Random.MersenneTwister(42),
                loglevel::Logging.LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

Computes a Groebner basis of the ideal generated by `polynomials`.

If `reduced` is set, returns the reduced basis, which is *unique*.

Uses the ordering on `polynomials` by default.
If `ordering` is explicitly specialized, it takes precedence.
**(On the fly ordering change not implemented yet :D)**

The algorithm is randomized by default, but
this can be changed with the `randomized` param.
**(Derandomized version not implemented yet :D)**

"""
function groebner(
            polynomials::Vector{Poly};
            reduced::Bool=true,
            ordering::Symbol=:input,
            randomized::Bool=true,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::Logging.LogLevel=Logging.Warn
            ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input polynomials =#
    # Copies input, so that polys would not be changed itself.
    ring, exps, coeffs = convert_to_internal(polynomials, ordering)

    #= compute the groebner basis =#
    if ring.ch != 0
        # if finite field
        # Always returns UInt coefficients #
        bexps, bcoeffs = groebner_ff(ring, exps, coeffs, reduced, rng)
    else
        # if rational coefficients
        # Always returns rational coefficients #
        bexps, bcoeffs = groebner_qq(ring, exps, coeffs, reduced, randomized, rng)
    end

    #=
    Assuming ordering of `bexps` here matches `ring.ord`
    =#

    #= revert logger =#
    Logging.global_logger(prev_logger)

    # ring contains ordering of computation, it is the requested ordering
    #= convert result back to representation of input =#
    convert_to_output(ring, polynomials, bexps, bcoeffs)
end

#######################################
# Finite field groebner

function groebner_ff(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{UInt64}},
            reduced::Bool,
            rng::Rng) where {Rng<:Random.AbstractRNG}
    # specialize on ordering (not yet)
    # groebner_ff(ring, exps, coeffs, reduced, rng, Val(ring.ord))
    f4(ring, exps, coeffs, rng, reduced)
end

#######################################
# Rational field groebner

function modular_f4_step(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{UInt64}},
            rng::Rng,
            reduced::Bool
            ) where {Rng<:Random.AbstractRNG}

    f4(ring, exps, coeffs, rng, reduced)
end

function groebner_qq(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{Rational{BigInt}}},
            reduced::Bool,
            randomized::Bool,
            rng::Rng,
            ) where {Rng<:Random.AbstractRNG}

    # scale coefficients to integer ring inplace
    coeffs_zz = scale_denominators!(coeffs)

    gbcoeffs_accum = Vector{Vector{BigInt}}(undef, 0)
    gbexps = Vector{Vector{Vector{UInt16}}}(undef, 0)
    gbcoeffs_qq = Vector{Vector{Rational{BigInt}}}(undef, 0)

    prime::Int64 = 1
    modulo = BigInt(1)
    moduli = Int[]

    i = 1
    while true
        # lucky reduction prime
        prime  = nextluckyprime(coeffs_zz, prime)
        push!(moduli, prime)
        @info "$i: selected lucky prime $prime"

        # compute the image of coeffs_zz in GF(prime),
        # by coercing each coefficient into the finite field
        ring_ff, coeffs_ff = reduce_modulo(coeffs_zz, ring, prime)

        # groebner basis over finite field ideal
        # TODO: gbexps can be only computed once
        @info "Computing Groebner basis"
        gbexps, gbcoeffs_ff = modular_f4_step(
                                    ring_ff, exps, coeffs_ff,
                                    rng, reduced)

        # TODO: add majority rule based choice

        # reconstruct basis coeffs into integers
        # from the previously accumulated basis and the new one,
        @info "CRT modulo ($modulo, $(ring_ff.ch))"
        gbcoeffs_zz, modulo = reconstruct_crt!(
                            gbcoeffs_accum, modulo,
                            gbcoeffs_ff, ring_ff.ch)

        gbcoeffs_accum = gbcoeffs_zz

        # try to reconstruct basis coeffs from integers
        # into rationals
        @info "Reconstructing modulo $modulo"
        gbcoeffs_qq = reconstruct_modulo(gbcoeffs_zz, modulo)

        # run correctness checks to assure the reconstrction is correct
        if correctness_check(ring, exps, coeffs_zz, gbexps,
                                gbcoeffs_qq, moduli, randomized, rng)
            break
        end


        # not correct, goto next prime
        i += 1
        if i > 10000
            @error "Something probably went wrong in groebner.."
            return
        end
    end

    gbexps, gbcoeffs_qq
end

#######################################
# Generic isgroebner


"""
    function isgroebner(
                polynomials::Vector{Poly};
                ordering::Symbol=:input,
                randomized::Bool=true,
                rng::Rng=Random.MersenneTwister(42),
                loglevel::Logging.LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

Checks if `polynomials` forms a Groebner basis.

Uses the ordering on `polynomials` by default.
If `ordering` is explicitly specialized, it takes precedence.
**(On the fly ordering change not implemented yet :D)**

The algorithm is randomized by default, but
this can be changed with the `randomized` param.
**(Derandomized version not implemented yet :D)**

"""
function isgroebner(
            polynomials::Vector{Poly};
            ordering=:input,
            randomized::Bool=true,
            rng::Rng=Random.MersenneTwister(42),
            loglevel::LogLevel=Logging.Warn
    ) where {Poly, Rng<:Random.AbstractRNG}

    #= set the logger =#
    prev_logger = Logging.global_logger(ConsoleLogger(stderr, loglevel))

    #= extract ring information, exponents and coefficients
       from input polynomials =#
    # Copies input, so that polys would not be changed itself.
    ring, exps, coeffs = convert_to_internal(polynomials, ordering)

    #= compute the groebner basis =#
    if ring.ch != 0
        # if finite field
        # Always returns UInt coefficients #
        flag = isgroebner_ff(ring, exps, coeffs, rng)
    else
        # if rational coefficients
        # Always returns rational coefficients #
        flag = isgroebner_qq(ring, exps, coeffs, randomized, rng)
    end

    #=
    Assuming ordering of `bexps` here matches `ring.ord`
    =#

    #= revert logger =#
    Logging.global_logger(prev_logger)

    flag
end

# UWU!
function isgroebner_ff(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{UInt64}},
            rng)

    isgroebner_f4(ring, exps, coeffs, rng)
end

# TODO
function isgroebner_qq(
            ring::PolyRing,
            exps::Vector{Vector{Vector{UInt16}}},
            coeffs::Vector{Vector{Rational{BigInt}}},
            randomized::Bool,
            rng)

    if randomized
        coeffs_zz = scale_denominators!(coeffs)
        goodprime = nextgoodprime(coeffs_zz, Int[], 2^30 + 3)
        ring_ff, coeffs_ff = reduce_modulo(coeffs_zz, ring, goodprime)
        isgroebner_f4(ring_ff, exps, coeffs_ff, rng)
    else
        error("Sorry, not randomized version is not implemented yet.")
    end
end

#------------------------------------------------------------------------------
